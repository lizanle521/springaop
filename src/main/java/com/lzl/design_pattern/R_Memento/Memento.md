### Memento模式
我们在使用文本编辑器写文件时，如果不小心删除了某句话，可以通过撤销功能将文件恢复至之前的状态。
有些文本编辑器甚至支持多次撤销，能够恢复很久一千的版本。
使用面向对象编程的方式实现撤销功能时，需要保存实例的相关状态信息。然后，在撤销时，还需要根据所保存
的信息将实例恢复至原来的状态。
需要恢复实例，需要一个可以自由访问的实例内部结构的权限。但是如果稍有不注意，就可能会将依赖于实例
内部结构的代码分散的编写在程序中的各个地方，导致程序变的难以维护。这种就破坏了封装性。
通过引入表示实例状态的角色，可以在保存和恢复实例时有效的防止对象的封装性遭到破坏。

### 示例程序
下面我们来看一个Memento模式的示例程序。这是一个收集水果和获取金钱和获取金钱的掷骰子游戏。游戏规则
很简单，具体如下：
- 游戏是自动进行的
- 游戏的主人公通过掷骰子来决定下一个状态
- 当骰子点数为1的时候，主人公的金钱会增加
- 当骰子点数为2的时候，主人公的金钱会减少
- 当骰子点数为6的时候，主人公会得到水果
- 当主人公没有钱的时候游戏就会结束

### Memento类
Memento类表示Gamer主人的状态
Memento类和Gamer都位于game包下
memento类中有两个字段，即meney和fruits. Momey 表示主人公现在所持有的金钱数目，fruits表示目前为止
获取的水果，之所以没将money和fruits的可见性设置为private，是因为我们希望在game包下的Gamer类可以
访问这两个字段。
getMoney方法的作用是获取主人公当前的金钱数目。
Memento类的构造函数可见性并非public，因此不是任何其他类都可以生成Memento类的实例。只有在同一个包
下的其他类才能调用Memento类的构造函数
addFruit方法用于添加所获得的水果，该方法的可见性也不是public。这是因为只有同一个包下的其他类
才能添加水果。因此，无法从game包外部改变Memento内部的状态
